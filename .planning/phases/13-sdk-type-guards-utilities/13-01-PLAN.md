---
phase: 13-sdk-type-guards-utilities
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [packages/sdk/src/utils.ts]
autonomous: true

must_haves:
  truths:
    - "TypeScript narrows PaymentPayload to PaymentPayloadV1 when isPaymentPayloadV1 returns true"
    - "TypeScript narrows PaymentPayload to PaymentPayloadV2 when isPaymentPayloadV2 returns true"
    - "PaymentRequirements can be narrowed to V1 or V2 at runtime using type guards"
    - "getSchemeNetwork extracts scheme and network from both v1 and v2 payloads"
    - "Switch statements over PaymentPayload.x402Version trigger compile error when case is missing"
  artifacts:
    - path: "packages/sdk/src/utils.ts"
      provides: "Type guards and utilities for versioned types"
      exports: ["isPaymentPayloadV1", "isPaymentPayloadV2", "isPaymentRequirementsV1", "isPaymentRequirementsV2", "getSchemeNetwork", "getVersion", "assertNever"]
      min_lines: 100
  key_links:
    - from: "isPaymentPayloadV1"
      to: "PaymentPayloadV1"
      via: "value is Type predicate"
      pattern: "value is PaymentPayloadV1"
    - from: "isPaymentPayloadV2"
      to: "PaymentPayloadV2"
      via: "value is Type predicate"
      pattern: "value is PaymentPayloadV2"
    - from: "isPaymentRequirementsV1"
      to: "PaymentRequirementsV1"
      via: "in operator check for maxAmountRequired"
      pattern: "'maxAmountRequired' in"
    - from: "isPaymentRequirementsV2"
      to: "PaymentRequirementsV2"
      via: "in operator check for amount without maxAmountRequired"
      pattern: "'amount' in.*!.*'maxAmountRequired'"
---

<objective>
Add runtime type guards and utilities to packages/sdk/src/utils.ts enabling TypeScript consumers to safely discriminate between v1 and v2 payment formats and extract version-agnostic data.

Purpose: SDK consumers need runtime validation that narrows TypeScript types for safe handling of versioned payloads and requirements.
Output: utils.ts with 7 new exports (4 type guards, 2 extractors, 1 exhaustiveness helper).
</objective>

<execution_context>
@/Users/rawgroundbeef/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rawgroundbeef/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/rawgroundbeef/Projects/openfacilitator/.planning/PROJECT.md
@/Users/rawgroundbeef/Projects/openfacilitator/.planning/ROADMAP.md
@/Users/rawgroundbeef/Projects/openfacilitator/.planning/STATE.md
@/Users/rawgroundbeef/Projects/openfacilitator/.planning/phases/13-sdk-type-guards-utilities/13-CONTEXT.md
@/Users/rawgroundbeef/Projects/openfacilitator/.planning/phases/13-sdk-type-guards-utilities/13-RESEARCH.md
@/Users/rawgroundbeef/Projects/openfacilitator/packages/sdk/src/utils.ts
@/Users/rawgroundbeef/Projects/openfacilitator/packages/sdk/src/types.ts
@/Users/rawgroundbeef/Projects/openfacilitator/.planning/phases/12-sdk-type-definitions/12-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Add type guards for versioned PaymentPayload and PaymentRequirements</name>
  <files>packages/sdk/src/utils.ts</files>
  <action>
Add four type guards to utils.ts:

1. **isPaymentPayloadV1(value: unknown): value is PaymentPayloadV1**
   - Return false for null/undefined/non-object input (safe handling)
   - Check x402Version === 1
   - Check typeof scheme === 'string' && typeof network === 'string'
   - Check payload !== undefined && typeof payload === 'object'
   - Pattern from RESEARCH.md lines 306-316

2. **isPaymentPayloadV2(value: unknown): value is PaymentPayloadV2**
   - Same null/undefined/non-object safety as V1
   - Check x402Version === 2
   - Check typeof scheme === 'string' && typeof network === 'string'
   - Check payload !== undefined && typeof payload === 'object'
   - Pattern from RESEARCH.md lines 322-335

3. **isPaymentRequirementsV1(value: unknown): value is PaymentRequirementsV1**
   - Return false for null/undefined/non-object
   - Check 'maxAmountRequired' in value (V1 has maxAmountRequired field)
   - No x402Version field on PaymentRequirements (use field presence)
   - Pattern from RESEARCH.md lines 341-350

4. **isPaymentRequirementsV2(value: unknown): value is PaymentRequirementsV2**
   - Return false for null/undefined/non-object
   - Check 'amount' in value && !('maxAmountRequired' in value)
   - V2 has amount but NOT maxAmountRequired
   - Pattern from RESEARCH.md lines 357-365

Import types from ./types.js (PaymentPayloadV1, PaymentPayloadV2, PaymentRequirementsV1, PaymentRequirementsV2)

Why these patterns: Type guards create compile-time type narrowing contracts. PaymentPayload guards check x402Version discriminant. PaymentRequirements lack version field so we discriminate by unique field presence (maxAmountRequired for V1, amount without maxAmountRequired for V2).
  </action>
  <verify>
pnpm --filter=@openfacilitator/sdk build

Verification passes when:
- TypeScript compilation succeeds (no errors)
- Type guards correctly narrow types in IDE
  </verify>
  <done>
Four type guard functions exist in utils.ts with correct type predicate signatures. Build passes with no TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Add extraction utilities and exhaustiveness helper</name>
  <files>packages/sdk/src/utils.ts</files>
  <action>
Add three utility functions to utils.ts:

1. **getSchemeNetwork(payload: PaymentPayload): { scheme: string; network: string }**
   - Accept PaymentPayload union type
   - Return object with scheme and network fields
   - Both v1 and v2 have scheme/network at top level (version-agnostic extraction)
   - Pattern from RESEARCH.md lines 371-381

2. **getVersion(payload: PaymentPayload): 1 | 2**
   - Accept PaymentPayload union type
   - Return payload.x402Version (literal type 1 | 2)
   - Useful for switch statements
   - Pattern from RESEARCH.md lines 388-391

3. **assertNever(value: never, message?: string): never**
   - Accept never type (exhaustiveness checking)
   - Throw Error with message (default: "Unhandled discriminated union member: {JSON.stringify(value)}")
   - Must have return type `never`
   - Pattern from RESEARCH.md lines 398-405

Import PaymentPayload type from ./types.js for getSchemeNetwork and getVersion

Why these patterns: getSchemeNetwork/getVersion provide version-agnostic access to common fields. assertNever catches unhandled union cases at compile time (TypeScript errors if switch/if-else doesn't handle all versions).
  </action>
  <verify>
pnpm --filter=@openfacilitator/sdk build

Verification passes when:
- TypeScript compilation succeeds
- getSchemeNetwork accepts both PaymentPayloadV1 and PaymentPayloadV2
- getVersion returns literal union 1 | 2 (not number)
- assertNever parameter typed as never
  </verify>
  <done>
Three utility functions exist in utils.ts. getSchemeNetwork extracts scheme/network, getVersion returns literal 1 | 2, assertNever throws with never return type. Build passes.
  </done>
</task>

</tasks>

<verification>
Run SDK build to verify type definitions and guards compile correctly:

```bash
pnpm --filter=@openfacilitator/sdk build
```

Success criteria:
- Build succeeds with zero TypeScript errors
- utils.ts exports 7 new functions (4 guards + 3 utilities)
- Type guards use `value is Type` predicate syntax
- All guards accept `unknown` input type
- getVersion returns literal type `1 | 2` not `number`
- assertNever accepts `never` and returns `never`
</verification>

<success_criteria>
1. isPaymentPayloadV1 and isPaymentPayloadV2 narrow PaymentPayload union in TypeScript
2. isPaymentRequirementsV1 and isPaymentRequirementsV2 narrow PaymentRequirements union
3. getSchemeNetwork extracts { scheme, network } from both v1 and v2 payloads
4. getVersion returns 1 | 2 literal type for switch statement exhaustiveness
5. assertNever provides compile-time exhaustiveness checking
6. All utilities handle null/undefined safely (return false for guards, throw for assertNever)
7. SDK builds successfully with pnpm --filter=@openfacilitator/sdk build
</success_criteria>

<output>
After completion, create `.planning/phases/13-sdk-type-guards-utilities/13-01-SUMMARY.md` following summary template structure.
</output>
